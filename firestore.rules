/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user profiles
 * and allows public read access to regenerative intents, with owner-only write access.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information. Only the user can read/write their own profile.
 * - /regenerative_intents/{intentId}: Stores regenerative intent submissions. These are publicly readable,
 *   but only owners can create, update, or delete them.
 *
 * Key Security Decisions:
 * - Users can only manage their own profile data.
 * - Regenerative intents are publicly visible to encourage transparency.
 * - Access control is simplified by denormalizing ownership directly onto the documents.
 * - Admin roles are not currently implemented.
 *
 * Denormalization for Authorization:
 * - The /regenerative_intents/{intentId} documents are assumed to contain an `email` field representing the owner.
 *
 * Structural Segregation:
 * - Public user profiles and private user data are stored in separate locations to facilitate different access patterns.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their own profile.
     * @allow (get) User with ID 'user123' reads their own profile.
     * @allow (update) User with ID 'user123' updates their own profile.
     * @allow (delete) User with ID 'user123' deletes their own profile.
     * @deny (create) User with ID 'user123' attempts to create a profile for 'user456'.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      // Verify identity
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to determine if the current user is the owner of the document.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the current user is the existing owner of the document.
      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to regenerative intent submissions.
     * @path /regenerative_intents/{intentId}
     * @allow (get) Any user can read a regenerative intent.
     * @allow (list) Any user can list regenerative intents.
     * @allow (create) A user can create a regenerative intent where the email matches their auth.
     * @allow (update) Only the owner (email) of a regenerative intent can update it.
     * @allow (delete) Only the owner (email) of a regenerative intent can delete it.
     * @deny (create) A user attempts to create a regenerative intent with an email that doesn't match their auth.
     * @deny (update) A user attempts to update a regenerative intent they don't own.
     * @principle Allows public read access with owner-only writes.
     */
    match /regenerative_intents/{intentId} {
      // Verify identity
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to determine if the current user is the owner of the document.
      //CRITICAL: RegenerativeIntent entity must have a field 'email'
      function isOwner(email) {
          return request.auth.token.email == email;
      }

      // Helper function to check if the current user is the existing owner of the document.
      function isExistingOwner(email) {
        return isOwner(email) && resource.data != null && resource.data.email == email;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.email == request.auth.token.email;
      allow update: if isSignedIn() && isExistingOwner(resource.data.email);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.email);
    }
  }
}