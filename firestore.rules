/**
 * @fileoverview Firestore Security Rules for the regenerative actions platform.
 *
 * Core Philosophy:
 * This ruleset employs a strict user-ownership model for most data, with public read access where appropriate, and admin overrides where necessary.
 *
 * Data Structure:
 * - /actors/{actorId}: Represents an actor (individual or entity). Accessible only to the actor themselves.
 * - /actors/{actorId}/actions/{actionId}: Actions performed by an actor. Accessible only to the actor.
 * - /actors/{actorId}/actions/{actionId}/proofs/{proofId}: Proofs for an action. Accessible only to the actor.
 * - /actors/{actorId}/actions/{actionId}/certificate/current: Certificate for a verified action. Accessible only to the actor.
 * - /batches/{batchId}: Batches of anchored certificates. Publicly readable, writeable by admins only.
 * - /users/{userId}: User profile information, including admin roles. Accessible only to the user themselves, and updatable by admins.
 *
 * Key Security Decisions:
 * - Actors can only manage their own data (actions, proofs, certificates).
 * - Batches are publicly readable but only writable by admins.
 * - User profiles are readable only by the user, but can be updated by admins.
 * - Listing of actors or actions is not explicitly restricted, but should be carefully considered in the application's data access patterns.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to actor documents.
     * @path /actors/{actorId}
     * @allow (create) User with UID 'user_abc' can create an actor document if actorId matches their UID.
     * @allow (get, list) User with UID 'user_abc' can read the actor document if actorId matches their UID.
     * @allow (update, delete) User with UID 'user_abc' can update/delete the actor document if actorId matches their UID.
     * @deny (create) User with UID 'user_xyz' cannot create an actor document if actorId is 'user_abc'.
     * @deny (get, list) User with UID 'user_xyz' cannot read the actor document if actorId is 'user_abc'.
     * @deny (update, delete) User with UID 'user_xyz' cannot update/delete the actor document if actorId is 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /actors/{actorId} {
      allow get, list: if isSignedIn() && isOwner(actorId);
      allow create: if isSignedIn() && isOwner(actorId) && request.resource.data.regenId == actorId;
      allow update: if isSignedIn() && isExistingOwner(actorId) && request.resource.data.regenId == resource.data.regenId;
      allow delete: if isSignedIn() && isExistingOwner(actorId);
    }

    /**
     * @description Controls access to action documents under a specific actor.
     * @path /actors/{actorId}/actions/{actionId}
     * @allow (create) User with UID 'user_abc' can create an action under their actor document (actorId = 'user_abc').
     * @allow (get, list) User with UID 'user_abc' can read their own actions (actorId = 'user_abc').
     * @allow (update, delete) User with UID 'user_abc' can update/delete their own actions (actorId = 'user_abc').
     * @deny (create) User with UID 'user_xyz' cannot create an action under actorId 'user_abc'.
     * @deny (get, list) User with UID 'user_xyz' cannot read actions under actorId 'user_abc'.
     * @deny (update, delete) User with UID 'user_xyz' cannot update/delete actions under actorId 'user_abc'.
     * @principle Enforces strict ownership for actions within the actor's scope.
     */
    match /actors/{actorId}/actions/{actionId} {
      allow get, list: if isSignedIn() && isOwner(actorId);
      allow create: if isSignedIn() && isOwner(actorId);
      allow update: if isSignedIn() && isExistingOwner(actorId);
      allow delete: if isSignedIn() && isExistingOwner(actorId);
    }

    /**
     * @description Controls access to proof documents for a specific action.
     * @path /actors/{actorId}/actions/{actionId}/proofs/{proofId}
     * @allow (create) User with UID 'user_abc' can create proofs for their actions (actorId = 'user_abc').
     * @allow (get, list) User with UID 'user_abc' can read proofs for their own actions (actorId = 'user_abc').
     * @allow (update, delete) User with UID 'user_abc' can update/delete proofs for their own actions (actorId = 'user_abc').
     * @deny (create) User with UID 'user_xyz' cannot create proofs under actorId 'user_abc'.
     * @deny (get, list) User with UID 'user_xyz' cannot read proofs under actorId 'user_abc'.
     * @deny (update, delete) User with UID 'user_xyz' cannot update/delete proofs under actorId 'user_abc'.
     * @principle Enforces strict ownership for proofs linked to actions.
     */
    match /actors/{actorId}/actions/{actionId}/proofs/{proofId} {
      allow get, list: if isSignedIn() && isOwner(actorId);
      allow create: if isSignedIn() && isOwner(actorId);
      allow update: if isSignedIn() && isExistingOwner(actorId);
      allow delete: if isSignedIn() && isExistingOwner(actorId);
    }

    /**
     * @description Controls access to certificate documents for a specific action.
     * @path /actors/{actorId}/actions/{actionId}/certificate/current
     * @allow (create) User with UID 'user_abc' can create a certificate for their action (actorId = 'user_abc').
     * @allow (get, list) User with UID 'user_abc' can read the certificate for their action (actorId = 'user_abc').
     * @allow (update, delete) User with UID 'user_abc' can update/delete the certificate for their action (actorId = 'user_abc').
     * @deny (create) User with UID 'user_xyz' cannot create a certificate under actorId 'user_abc'.
     * @deny (get, list) User with UID 'user_xyz' cannot read a certificate under actorId 'user_abc'.
     * @deny (update, delete) User with UID 'user_xyz' cannot update/delete a certificate under actorId 'user_abc'.
     * @principle Enforces strict ownership for certificates linked to actions.
     */
    match /actors/{actorId}/actions/{actionId}/certificate/current {
      allow get, list: if isSignedIn() && isOwner(actorId);
      allow create: if isSignedIn() && isOwner(actorId);
      allow update: if isSignedIn() && isExistingOwner(actorId);
      allow delete: if isSignedIn() && isExistingOwner(actorId);
    }

    /**
     * @description Controls access to batch documents.
     * @path /batches/{batchId}
     * @allow (get, list) Any user can read batch documents.
     * @allow (create, update, delete) Only admins can create, update, or delete batch documents.
     * @deny (create, update, delete) Non-admin users cannot create, update, or delete batch documents.
     * @principle Public read access with admin-only writes.
     */
    match /batches/{batchId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

       /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (get, list) User with UID 'user_abc' can read their own profile (userId = 'user_abc').
     * @allow (create) User with UID 'user_abc' can create their own profile (userId = 'user_abc').
     * @allow (update) User with UID 'user_abc' can update their own profile (userId = 'user_abc') or an admin can update any profile.
     * @allow (delete) User with UID 'user_abc' can delete their own profile (userId = 'user_abc') or an admin can delete any profile.
     * @deny (get, list) User with UID 'user_xyz' cannot read the profile of user 'user_abc'.
     * @deny (create) User with UID 'user_xyz' cannot create a profile for user 'user_abc'.
     * @deny (update) User with UID 'user_xyz' cannot update the profile of user 'user_abc'.
     * @deny (delete) User with UID 'user_xyz' cannot delete the profile of user 'user_abc'.
     * @principle Users can only manage their own profile, with admin override for updates.
     */
    match /users/{userId} {
          allow get: if isSignedIn() && isOwner(userId);
          allow list: if isSignedIn() && isOwner(userId);
          allow create: if isSignedIn() && isOwner(userId);
          allow update: if (isSignedIn() && isOwner(userId)) || isAdmin();
          allow delete: if (isSignedIn() && isOwner(userId)) || isAdmin();
    }

    // Define helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
  }
}