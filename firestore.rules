/**
 * @fileOverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a combination of user-owned data (user profiles) and public read access with owner-only writes (regenerative intents).
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information, accessible only to the owning user.
 * - /regenerative_intents/{intentId}: Stores submitted regenerative intents, publicly readable but writable only by the authenticated user who created them.
 *
 * Key Security Decisions:
 * - User profiles are private and only accessible to the owning user.
 * - Regenerative intents are publicly readable to encourage community engagement, but can only be created, updated, or deleted by their creator.
 * - Data shape validation is relaxed to allow for rapid prototyping. Only authorization-critical fields are validated.
 *
 * Denormalization for Authorization:
 * - Regenerative intents MUST include a creatorId field that matches the authenticated user's UID. This enables secure owner-only write rules without requiring additional reads.
 *
 * Structural Segregation:
 * - Public read access is enabled through the top-level /regenerative_intents collection, avoiding the need for a boolean flag to distinguish between public and private intents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to user profile information.
     * @path /users/{userId}
     * @allow (create) - Authenticated user creates their profile.
     * @allow (get, list) - Authenticated user reads their own profile.
     * @allow (update, delete) - Authenticated user updates or deletes their own profile.
     * @deny (create, get, list, update, delete) - Any other user attempts to access this profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId) && request.resource.data.displayName == resource.data.displayName;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows public read access to regenerative intents, but restricts write access to the intent's owner.
     * @path /regenerative_intents/{intentId}
     * @allow (get, list) - Any user can read a regenerative intent.
     * @allow (create) - Authenticated user can create a regenerative intent, with the 'creatorId' field matching their UID.
     * @allow (update, delete) - The owner (creator) of the intent can modify or delete it.
     * @deny (create, update, delete) - Unauthenticated users cannot create, update, or delete intents.
     * @deny (create, update, delete) - Users cannot modify or delete intents they don't own.
     * @principle Enforces owner-only writes for regenerative intents, while allowing public reads.
     */
    match /regenerative_intents/{intentId} {
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(ownerId) {
          return isOwner(ownerId) && resource != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.email);
      allow delete: if isExistingOwner(resource.data.email);
    }
  }
}