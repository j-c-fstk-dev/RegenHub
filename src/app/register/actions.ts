'use server';

import { z } from 'zod';
import {
  aiAssistedIntentVerification,
  AIAssistedIntentVerificationInput,
} from '@/ai/flows/ai-assisted-intent-verification';
import { getStorage, ref, uploadString, getDownloadURL } from 'firebase/storage';
import { collection, addDoc, serverTimestamp, updateDoc, Firestore } from 'firebase/firestore';
import { initializeFirebase } from '@/firebase'; // This is now safe as we don't call it on server

const formSchema = z.object({
  actionName: z.string().min(5),
  actionType: z.string(),
  actionDate: z.string(),
  location: z.string().min(3),
  numberOfParticipants: z.coerce.number().int().min(1),
  shortDescription: z.string().min(20).max(500),
  media: z.array(z.string()), // Array of data URIs
  socialMediaLinks: z.array(z.string().url()).optional(),
  responsibleName: z.string().min(2),
  projectName: z.string().optional(),
  customTag: z.string().optional(),
  email: z.string().email(),
});

type ActionInput = z.infer<typeof formSchema>;

async function uploadMedia(mediaDataUris: string[], intentId: string): Promise<string[]> {
  // We re-initialize here on the server side, but only for storage operations.
  // This is a separate context from the client.
  const { firebaseApp } = initializeFirebase();
  const storage = getStorage(firebaseApp);
  const urls: string[] = [];

  for (let i = 0; i < mediaDataUris.length; i++) {
    const dataUri = mediaDataUris[i];
    const fileExtension = dataUri.substring(dataUri.indexOf('/') + 1, dataUri.indexOf(';'));
    const storageRef = ref(storage, `intents/${intentId}/media_${Date.now()}.${fileExtension}`);
    
    const base64Data = dataUri.split(',')[1];
    
    const snapshot = await uploadString(storageRef, base64Data, 'base64', {
      contentType: dataUri.substring(dataUri.indexOf(':') + 1, dataUri.indexOf(';')),
    });
    const downloadURL = await getDownloadURL(snapshot.ref);
    urls.push(downloadURL);
  }

  return urls;
}

export async function submitIntent(
  data: ActionInput,
): Promise<{ success: boolean; error?: string; intentId?: string }> {
  const validatedData = formSchema.safeParse(data);

  if (!validatedData.success) {
    console.error('Invalid data provided:', validatedData.error.flatten().fieldErrors);
    return { success: false, error: 'Invalid data provided.' };
  }
  
  const { media, ...formData } = validatedData.data;

  try {
    // This is a server-side initialization, safe to use in a server action.
    const { firestore } = initializeFirebase();
    
    const newIntentRef = collection(firestore, 'regenerative_intents');
    const docRef = await addDoc(newIntentRef, {
        ...formData,
        status: 'pending',
        submissionDate: serverTimestamp(),
        mediaUrls: [], 
        certificateRequested: true,
        autoGeneratedTag: '',
    });

    const intentId = docRef.id;

    const mediaUrls = await uploadMedia(media, intentId);

    await updateDoc(docRef, { mediaUrls });

    // AI verification can run in the background
    const aiInput: AIAssistedIntentVerificationInput = {
      actionName: formData.actionName,
      actionType: formData.actionType,
      actionDescription: formData.shortDescription,
      location: formData.location,
      numberOfParticipants: formData.numberOfParticipants,
      photos: media, // Send data URIs to AI
      socialMediaLinks: formData.socialMediaLinks || [],
    };
    
    aiAssistedIntentVerification(aiInput).then(verificationResult => {
      console.log('AI Verification Result:', verificationResult);
      updateDoc(docRef, { aiVerification: verificationResult });
    });

    return { success: true, intentId };

  } catch (error) {
    console.error('Error during intent submission:', error);
    if (error instanceof Error) {
        return { success: false, error: error.message };
    }
    return { success: false, error: 'An unknown error occurred during submission.' };
  }
}